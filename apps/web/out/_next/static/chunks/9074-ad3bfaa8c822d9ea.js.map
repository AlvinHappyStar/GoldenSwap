{"version":3,"file":"static/chunks/9074-ad3bfaa8c822d9ea.js","mappings":"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","sources":["webpack://_N_E/./src/state/info/queries/helpers.ts","webpack://_N_E/./src/state/info/queries/pools/chartData.ts","webpack://_N_E/./src/utils/getLpFeesAndApr.ts","webpack://_N_E/./src/views/Info/hooks/useBlocksFromTimestamps.ts","webpack://_N_E/./src/state/info/queries/pools/topPools.ts","webpack://_N_E/./src/state/info/queries/pools/poolData.ts","webpack://_N_E/./src/state/info/queries/pools/transactions.ts","webpack://_N_E/./src/state/info/queries/protocol/chart.ts","webpack://_N_E/./src/state/info/queries/protocol/overview.ts","webpack://_N_E/./src/state/info/queries/protocol/transactions.ts","webpack://_N_E/./src/state/info/queries/tokens/chartData.ts","webpack://_N_E/./src/state/info/queries/tokens/poolsForToken.ts","webpack://_N_E/./src/state/info/queries/tokens/priceData.ts","webpack://_N_E/./src/state/info/queries/tokens/topTokens.ts","webpack://_N_E/./src/state/info/queries/tokens/tokenData.ts","webpack://_N_E/./src/state/info/queries/tokens/transactions.ts","webpack://_N_E/./src/state/info/hooks.ts","webpack://_N_E/./src/state/info/types.ts","webpack://_N_E/./src/utils/getAprsForStableFarm.ts","webpack://_N_E/./src/utils/getChangeForPeriod.ts","webpack://_N_E/./src/utils/getDeltaTimestamps.ts","webpack://_N_E/./src/views/Info/utils/infoDataHelpers.ts","webpack://_N_E/<anon>"],"sourcesContent":["import { ChainId } from '@pancakeswap/sdk'\nimport fromPairs from 'lodash/fromPairs'\nimport chunk from 'lodash/chunk'\nimport uniq from 'lodash/uniq'\nimport mapValues from 'lodash/mapValues'\nimport { ONE_DAY_UNIX } from 'config/constants/info'\nimport IPancakePairABI from 'config/abi/IPancakePair.json'\nimport bep20Abi from 'config/abi/erc20.json'\nimport { multicallv2 } from 'utils/multicall'\nimport { getUnixTime } from 'date-fns'\nimport { TransactionType } from 'state/info/types'\nimport { ChartEntry } from '../types'\nimport { MultiChainName, multiChainStartTime } from '../constant'\nimport { MintResponse, SwapResponse, BurnResponse, TokenDayData, PairDayData, PancakeDayData } from './types'\n\nexport const mapMints = (mint: MintResponse) => {\n  return {\n    type: TransactionType.MINT,\n    hash: mint.id.split('-')[0],\n    timestamp: mint.timestamp,\n    sender: mint.to,\n    token0Symbol: mint.pair.token0.symbol,\n    token1Symbol: mint.pair.token1.symbol,\n    token0Address: mint.pair.token0.id,\n    token1Address: mint.pair.token1.id,\n    amountUSD: parseFloat(mint.amountUSD),\n    amountToken0: parseFloat(mint.amount0),\n    amountToken1: parseFloat(mint.amount1),\n  }\n}\n\nexport const mapBurns = (burn: BurnResponse) => {\n  return {\n    type: TransactionType.BURN,\n    hash: burn.id.split('-')[0],\n    timestamp: burn.timestamp,\n    sender: burn.sender,\n    token0Symbol: burn.pair.token0.symbol,\n    token1Symbol: burn.pair.token1.symbol,\n    token0Address: burn.pair.token0.id,\n    token1Address: burn.pair.token1.id,\n    amountUSD: parseFloat(burn.amountUSD),\n    amountToken0: parseFloat(burn.amount0),\n    amountToken1: parseFloat(burn.amount1),\n  }\n}\n\nexport const mapSwaps = (swap: SwapResponse) => {\n  return {\n    type: TransactionType.SWAP,\n    hash: swap.id.split('-')[0],\n    timestamp: swap.timestamp,\n    sender: swap.from,\n    token0Symbol: swap.pair.token0.symbol,\n    token1Symbol: swap.pair.token1.symbol,\n    token0Address: swap.pair.token0.id,\n    token1Address: swap.pair.token1.id,\n    amountUSD: parseFloat(swap.amountUSD),\n    amountToken0: parseFloat(swap.amount0In) - parseFloat(swap.amount0Out),\n    amountToken1: parseFloat(swap.amount1In) - parseFloat(swap.amount1Out),\n  }\n}\n\nexport const mapDayData = (tokenDayData: TokenDayData | PancakeDayData): ChartEntry => ({\n  date: tokenDayData.date,\n  volumeUSD: parseFloat(tokenDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(tokenDayData.totalLiquidityUSD),\n})\n\nexport const mapPairDayData = (pairDayData: PairDayData): ChartEntry => ({\n  date: pairDayData.date,\n  volumeUSD: parseFloat(pairDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(pairDayData.reserveUSD),\n})\n\ntype PoolOrTokenFetchFn = (\n  chainName: MultiChainName,\n  skip: number,\n  address: string,\n) => Promise<{ data?: ChartEntry[]; error: boolean }>\n\ntype OverviewFetchFn = (chianName: MultiChainName, skip: number) => Promise<{ data?: ChartEntry[]; error: boolean }>\n\n// Common helper function to retrieve chart data\n// Used for both Pool and Token charts\nexport const fetchChartData = async (\n  chainName: MultiChainName,\n  getEntityDayDatas: OverviewFetchFn,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  let chartEntries: ChartEntry[] = []\n  let error = false\n  let skip = 0\n  let allFound = false\n\n  while (!allFound && !error) {\n    // eslint-disable-next-line no-await-in-loop\n    const { data, error: fetchError } = await getEntityDayDatas(chainName, skip)\n    skip += 1000\n    allFound = data?.length < 1000 || skip > 2000\n    error = fetchError\n    if (data) {\n      chartEntries = chartEntries.concat(data)\n    }\n  }\n\n  if (error || chartEntries.length === 0) {\n    return {\n      error: true,\n    }\n  }\n\n  const formattedDayDatas = fromPairs(\n    chartEntries.map((dayData) => {\n      // At this stage we track unix day ordinal for each data point to check for empty days later\n      const dayOrdinal = parseInt((dayData.date / ONE_DAY_UNIX).toFixed(0))\n      return [dayOrdinal, dayData]\n    }),\n  )\n\n  console.warn(formattedDayDatas)\n\n  const availableDays = Object.keys(formattedDayDatas).map((dayOrdinal) => parseInt(dayOrdinal, 10))\n\n  const firstAvailableDayData = formattedDayDatas[availableDays[0]]\n  // fill in empty days ( there will be no day datas if no trades made that day )\n  let timestamp = firstAvailableDayData?.date ?? multiChainStartTime[chainName]\n  let latestLiquidityUSD = firstAvailableDayData?.liquidityUSD ?? 0\n  const endTimestamp = getUnixTime(new Date())\n  while (timestamp < endTimestamp - ONE_DAY_UNIX) {\n    timestamp += ONE_DAY_UNIX\n    const dayOrdinal = parseInt((timestamp / ONE_DAY_UNIX).toFixed(0), 10)\n    if (!Object.keys(formattedDayDatas).includes(dayOrdinal.toString())) {\n      formattedDayDatas[dayOrdinal] = {\n        date: timestamp,\n        volumeUSD: 0,\n        liquidityUSD: latestLiquidityUSD,\n      }\n    } else {\n      latestLiquidityUSD = formattedDayDatas[dayOrdinal].liquidityUSD\n    }\n  }\n\n  return {\n    data: Object.values(formattedDayDatas),\n    error: false,\n  }\n}\n\nexport const fetchChartDataWithAddress = async (\n  chainName: MultiChainName,\n  getEntityDayDatas: PoolOrTokenFetchFn,\n  address: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  let chartEntries: ChartEntry[] = []\n  let error = false\n  let skip = 0\n  let allFound = false\n\n  while (!allFound && !error) {\n    // eslint-disable-next-line no-await-in-loop\n    const { data, error: fetchError } = await getEntityDayDatas(chainName, skip, address)\n    skip += 1000\n    allFound = data?.length < 1000 || skip > 2000\n    error = fetchError\n    if (data) {\n      chartEntries = chartEntries.concat(data)\n    }\n  }\n\n  if (error || chartEntries.length === 0) {\n    return {\n      error: true,\n    }\n  }\n\n  const formattedDayDatas = fromPairs(\n    chartEntries.map((dayData) => {\n      // At this stage we track unix day ordinal for each data point to check for empty days later\n      const dayOrdinal = parseInt((dayData.date / ONE_DAY_UNIX).toFixed(0))\n      return [dayOrdinal, dayData]\n    }),\n  )\n  console.warn(formattedDayDatas)\n\n  const availableDays = Object.keys(formattedDayDatas).map((dayOrdinal) => parseInt(dayOrdinal, 10))\n\n  const firstAvailableDayData = formattedDayDatas[availableDays[0]]\n  // fill in empty days ( there will be no day datas if no trades made that day )\n  let timestamp = firstAvailableDayData?.date ?? multiChainStartTime[chainName]\n  let latestLiquidityUSD = firstAvailableDayData?.liquidityUSD ?? 0\n  const endTimestamp = getUnixTime(new Date())\n  while (timestamp < endTimestamp - ONE_DAY_UNIX) {\n    timestamp += ONE_DAY_UNIX\n    const dayOrdinal = parseInt((timestamp / ONE_DAY_UNIX).toFixed(0), 10)\n    if (!Object.keys(formattedDayDatas).includes(dayOrdinal.toString())) {\n      formattedDayDatas[dayOrdinal] = {\n        date: timestamp,\n        volumeUSD: 0,\n        liquidityUSD: latestLiquidityUSD,\n      }\n    } else {\n      latestLiquidityUSD = formattedDayDatas[dayOrdinal].liquidityUSD\n    }\n  }\n\n  return {\n    data: Object.values(formattedDayDatas),\n    error: false,\n  }\n}\n\nexport async function getPairTokenMap(poolAddresses: string[], chainName: 'ETH' | 'BSC') {\n  let rawPairTokenResults: string[][]\n  const calls = poolAddresses\n    .map((poolAddress) => {\n      return [\n        { address: poolAddress, name: 'token0' },\n        { address: poolAddress, name: 'token1' },\n      ]\n    })\n    .flat()\n  try {\n    rawPairTokenResults = await multicallv2({\n      abi: IPancakePairABI,\n      calls,\n      options: { requireSuccess: false },\n      chainId: chainName === 'ETH' ? ChainId.ETHEREUM : ChainId.BSC,\n    })\n  } catch (error) {\n    console.info('Error fetching tokenIds from pair')\n  }\n  const pairTokenResults = rawPairTokenResults\n    ? rawPairTokenResults.map((rawPairTokenResult) => rawPairTokenResult[0].toLowerCase())\n    : []\n  const pairTokenMap: { [tokenAddress: string]: { token0: string; token1: string } } = chunk(\n    pairTokenResults,\n    2,\n  ).reduce((acc, tokenResult, index) => {\n    return { ...acc, [poolAddresses[index].toLowerCase()]: { token0: tokenResult[0], token1: tokenResult[1] } }\n  }, {})\n  let rawTokenResults\n  const uniquePairTokenResults = uniq(pairTokenResults)\n  const tokenCalls = uniquePairTokenResults\n    .map((pairToken) => {\n      return [\n        { address: pairToken, name: 'name' },\n        { address: pairToken, name: 'symbol' },\n      ]\n    })\n    .flat()\n  try {\n    rawTokenResults = await multicallv2({\n      abi: bep20Abi,\n      calls: tokenCalls,\n      options: { requireSuccess: false },\n      chainId: chainName === 'ETH' ? ChainId.ETHEREUM : ChainId.BSC,\n    })\n  } catch (error) {\n    console.info('Error fetching tokenIds from pair')\n  }\n  const tokenResults = rawTokenResults ? rawTokenResults.map((rawTokenResult) => rawTokenResult[0]) : []\n  const tokenMap = chunk(tokenResults, 2).reduce((acc, tokenResult, index) => {\n    return { ...acc, [uniquePairTokenResults[index].toLowerCase()]: { name: tokenResult[0], symbol: tokenResult[1] } }\n  }, {})\n  return mapValues(pairTokenMap, (pairTokenValue) => {\n    return {\n      token0: { id: pairTokenValue.token0, ...tokenMap[pairTokenValue.token0] },\n      token1: { id: pairTokenValue.token1, ...tokenMap[pairTokenValue.token1] },\n    }\n  })\n}\n","import { gql } from 'graphql-request'\nimport { ChartEntry } from 'state/info/types'\nimport { PairDayDatasResponse } from '../types'\nimport { mapPairDayData, fetchChartDataWithAddress } from '../helpers'\nimport { getMultiChainQueryEndPointWithStableSwap, MultiChainName, multiChainStartTime } from '../../constant'\n\nconst getPoolChartData = async (\n  chainName: MultiChainName,\n  skip: number,\n  address: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  try {\n    const query = gql`\n      query pairDayDatas($startTime: Int!, $skip: Int!, $address: Bytes!) {\n        pairDayDatas(\n          first: 1000\n          skip: $skip\n          where: { pairAddress: $address, date_gt: $startTime }\n          orderBy: date\n          orderDirection: asc\n        ) {\n          date\n          dailyVolumeUSD\n          reserveUSD\n        }\n      }\n    `\n    const { pairDayDatas } = await getMultiChainQueryEndPointWithStableSwap(chainName).request<PairDayDatasResponse>(\n      query,\n      {\n        startTime: multiChainStartTime[chainName],\n        skip,\n        address,\n      },\n    )\n    const data = pairDayDatas.map(mapPairDayData)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch pool chart data', error)\n    return { error: true }\n  }\n}\n\nconst fetchPoolChartData = async (\n  chainName: MultiChainName,\n  address: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  return fetchChartDataWithAddress(chainName, getPoolChartData, address)\n}\n\nexport default fetchPoolChartData\n","import { TOTAL_FEE, LP_HOLDERS_FEE, WEEKS_IN_YEAR } from '../config/constants/info'\n\nexport const getLpFeesAndApr = (volumeUSD: number, volumeUSDWeek: number, liquidityUSD: number) => {\n  const totalFees24h = volumeUSD * TOTAL_FEE\n  const totalFees7d = volumeUSDWeek * TOTAL_FEE\n  const lpFees24h = volumeUSD * LP_HOLDERS_FEE\n  const lpFees7d = volumeUSDWeek * LP_HOLDERS_FEE\n\n  const lpApr7d = liquidityUSD > 0 ? (volumeUSDWeek * LP_HOLDERS_FEE * WEEKS_IN_YEAR * 100) / liquidityUSD : 0\n  return {\n    totalFees24h,\n    totalFees7d,\n    lpFees24h,\n    lpFees7d,\n    lpApr7d: lpApr7d !== Infinity ? lpApr7d : 0,\n  }\n}\n","import { useEffect, useState } from 'react'\nimport { useGetChainName } from 'state/info/hooks'\nimport { Block } from 'state/info/types'\nimport useSWRImmutable from 'swr/immutable'\nimport { getBlocksFromTimestamps } from 'utils/getBlocksFromTimestamps'\n\n/**\n * for a given array of timestamps, returns block entities\n * @param timestamps\n * @param sortDirection\n * @param skipCount\n */\nexport const useBlocksFromTimestamps = (\n  timestamps: number[],\n  sortDirection: 'asc' | 'desc' = 'desc',\n  skipCount = 1000,\n): {\n  blocks?: Block[]\n  error: boolean\n} => {\n  const [blocks, setBlocks] = useState<Block[]>()\n  const [error, setError] = useState(false)\n\n  const timestampsString = JSON.stringify(timestamps)\n  const blocksString = blocks ? JSON.stringify(blocks) : undefined\n  const chainName = useGetChainName()\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const timestampsArray = JSON.parse(timestampsString)\n      const result = await getBlocksFromTimestamps(timestampsArray, sortDirection, skipCount, chainName)\n      if (result.length === 0) {\n        setError(true)\n      } else {\n        setBlocks(result)\n      }\n    }\n    const blocksArray = blocksString ? JSON.parse(blocksString) : undefined\n    if (!blocksArray && !error && chainName) {\n      fetchData()\n    }\n  }, [blocksString, error, skipCount, sortDirection, timestampsString, chainName])\n\n  return {\n    blocks,\n    error,\n  }\n}\n\nexport const useBlockFromTimeStampSWR = (\n  timestamps: number[],\n  sortDirection: 'asc' | 'desc' | undefined = 'desc',\n  skipCount: number | undefined = 1000,\n) => {\n  const chainName = useGetChainName()\n  const timestampsString = JSON.stringify(timestamps)\n  const timestampsArray = JSON.parse(timestampsString)\n  const { data } = useSWRImmutable([`info/blocks/${timestampsString}`, chainName], () =>\n    getBlocksFromTimestamps(timestampsArray, sortDirection, skipCount, chainName),\n  )\n  return { blocks: data }\n}\n","import { gql } from 'graphql-request'\nimport { useEffect, useState } from 'react'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport {\n  checkIsStableSwap,\n  getMultiChainQueryEndPointWithStableSwap,\n  MultiChainName,\n  multiChainTokenBlackList,\n} from '../../constant'\nimport { useGetChainName } from '../../hooks'\n\ninterface TopPoolsResponse {\n  pairDayDatas: {\n    id: string\n  }[]\n}\n\n/**\n * Initial pools to display on the home page\n */\nconst fetchTopPools = async (chainName: MultiChainName, timestamp24hAgo: number): Promise<string[]> => {\n  const isStableSwap = checkIsStableSwap()\n  const firstCount = isStableSwap ? 100 : 30\n  let whereCondition =\n    chainName === 'BSC'\n      ? `where: { dailyTxns_gt: 300, token0_not_in: $blacklist, token1_not_in: $blacklist, date_gt: ${timestamp24hAgo} }`\n      : `where: { date_gt: ${timestamp24hAgo}, token0_not_in: $blacklist, token1_not_in: $blacklist, dailyVolumeUSD_gt: 2000 }`\n  if (isStableSwap) whereCondition = `where: { date_gt: ${timestamp24hAgo}}`\n  try {\n    const query = gql`\n      query topPools($blacklist: [String!]) {\n        pairDayDatas(\n          first: ${firstCount}\n          ${whereCondition}\n          orderBy: dailyVolumeUSD\n          orderDirection: desc\n        ) {\n          id\n        }\n      }\n    `\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TopPoolsResponse>(query, {\n      blacklist: multiChainTokenBlackList[chainName],\n    })\n    // pairDayDatas id has compound id \"0xPOOLADDRESS-NUMBERS\", extracting pool address with .split('-')\n    return data.pairDayDatas.map((p) => p.id.split('-')[0])\n  } catch (error) {\n    console.error('Failed to fetch top pools', error)\n    return []\n  }\n}\n\n/**\n * Fetch top addresses by volume\n */\nconst useTopPoolAddresses = (): string[] => {\n  const [topPoolAddresses, setTopPoolAddresses] = useState([])\n  const [timestamp24hAgo] = getDeltaTimestamps()\n  const chainName = useGetChainName()\n\n  useEffect(() => {\n    const fetch = async () => {\n      const addresses = await fetchTopPools(chainName, timestamp24hAgo)\n      setTopPoolAddresses(addresses)\n    }\n    if (topPoolAddresses.length === 0) {\n      fetch()\n    }\n  }, [topPoolAddresses, timestamp24hAgo, chainName])\n\n  return topPoolAddresses\n}\n\nexport const fetchTopPoolAddresses = async (chainName: MultiChainName) => {\n  const [timestamp24hAgo] = getDeltaTimestamps()\n\n  const addresses = await fetchTopPools(chainName, timestamp24hAgo)\n  return addresses\n}\n\nexport default useTopPoolAddresses\n","/* eslint-disable no-param-reassign */\nimport { gql } from 'graphql-request'\nimport { useEffect, useState } from 'react'\nimport { Block, PoolData } from 'state/info/types'\nimport { getChangeForPeriod } from 'utils/getChangeForPeriod'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport { getLpFeesAndApr } from 'utils/getLpFeesAndApr'\nimport { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { getPercentChange, getAmountChange } from 'views/Info/utils/infoDataHelpers'\n\nimport {\n  getMultiChainQueryEndPointWithStableSwap,\n  MultiChainName,\n  multiChainQueryMainToken,\n  checkIsStableSwap,\n} from '../../constant'\nimport { useGetChainName } from '../../hooks'\nimport { fetchTopPoolAddresses } from './topPools'\n\ninterface PoolFields {\n  id: string\n  reserve0: string\n  reserve1: string\n  reserveUSD: string\n  volumeUSD: string\n  volumeOutUSD?: string\n  token0Price: string\n  token1Price: string\n  token0?: {\n    id: string\n    symbol: string\n    name: string\n  }\n  token1?: {\n    id: string\n    symbol: string\n    name: string\n  }\n}\n\nexport interface FormattedPoolFields\n  extends Omit<\n    PoolFields,\n    'volumeUSD' | 'reserveUSD' | 'reserve0' | 'reserve1' | 'token0Price' | 'token1Price' | 'volumeOutUSD'\n  > {\n  volumeUSD: number\n  reserveUSD: number\n  reserve0: number\n  reserve1: number\n  token0Price: number\n  token1Price: number\n  volumeOutUSD?: number\n}\n\ninterface PoolsQueryResponse {\n  now: PoolFields[]\n  oneDayAgo: PoolFields[]\n  twoDaysAgo: PoolFields[]\n  oneWeekAgo: PoolFields[]\n  twoWeeksAgo: PoolFields[]\n}\n\n/**\n * Data for displaying pool tables (on multiple pages, used throughout the site)\n * Note: Don't try to refactor it to use variables, server throws error if blocks passed as undefined variable\n * only works if its hard-coded into query string\n */\nconst POOL_AT_BLOCK = (chainName: MultiChainName, block: number | null, pools: string[]) => {\n  const blockString = block ? `block: {number: ${block}}` : ``\n  const addressesString = `[\"${pools.join('\",\"')}\"]`\n  const volumeOutUSDString = checkIsStableSwap() ? 'volumeOutUSD' : ''\n\n  return `pairs(\n    where: { id_in: ${addressesString} }\n    ${blockString}\n    orderBy: trackedReserve${multiChainQueryMainToken[chainName]}\n    orderDirection: desc\n  ) {\n    id\n    reserve0\n    reserve1\n    reserveUSD\n    volumeUSD\n    ${volumeOutUSDString}\n    token0Price\n    token1Price\n    token0 {\n      id\n      symbol\n      name\n    }\n    token1 {\n      id\n      symbol\n      name\n    }\n  }`\n}\n\nexport const fetchPoolData = async (\n  block24h: number,\n  block48h: number,\n  block7d: number,\n  block14d: number,\n  poolAddresses: string[],\n  chainName: 'ETH' | 'BSC' = 'BSC',\n) => {\n  try {\n    const query = gql`\n      query pools {\n        now: ${POOL_AT_BLOCK(chainName, null, poolAddresses)}\n        oneDayAgo: ${POOL_AT_BLOCK(chainName, block24h, poolAddresses)}\n        twoDaysAgo: ${POOL_AT_BLOCK(chainName, block48h, poolAddresses)}\n        oneWeekAgo: ${POOL_AT_BLOCK(chainName, block7d, poolAddresses)}\n        twoWeeksAgo: ${POOL_AT_BLOCK(chainName, block14d, poolAddresses)}\n      }\n    `\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<PoolsQueryResponse>(query)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch pool data', error)\n    return { error: true }\n  }\n}\n\n// Transforms pools into \"0xADDRESS: { ...PoolFields }\" format and cast strings to numbers\nexport const parsePoolData = (pairs?: PoolFields[]) => {\n  if (!pairs) {\n    return {}\n  }\n  return pairs.reduce((accum: { [address: string]: FormattedPoolFields }, poolData) => {\n    const { volumeUSD, reserveUSD, reserve0, reserve1, token0Price, token1Price, volumeOutUSD } = poolData\n    accum[poolData.id.toLowerCase()] = {\n      ...poolData,\n      volumeUSD: parseFloat(volumeUSD),\n      volumeOutUSD: volumeOutUSD && parseFloat(volumeOutUSD),\n      reserveUSD: parseFloat(reserveUSD),\n      reserve0: parseFloat(reserve0),\n      reserve1: parseFloat(reserve1),\n      token0Price: parseFloat(token0Price),\n      token1Price: parseFloat(token1Price),\n    }\n    return accum\n  }, {})\n}\n\ninterface PoolDatas {\n  error: boolean\n  data?: {\n    [address: string]: PoolData\n  }\n}\n\n/**\n * Fetch top pools by liquidity\n */\nconst usePoolDatas = (poolAddresses: string[]): PoolDatas => {\n  const [fetchState, setFetchState] = useState<PoolDatas>({ error: false })\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24h, t48h, t7d, t14d])\n  const [block24h, block48h, block7d, block14d] = blocks ?? []\n  const chainName = useGetChainName()\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error, data } = await fetchPoolData(\n        block24h.number,\n        block48h.number,\n        block7d.number,\n        block14d.number,\n        poolAddresses,\n        chainName,\n      )\n      if (error) {\n        setFetchState({ error: true })\n      } else {\n        const formattedPoolData = parsePoolData(data?.now)\n        const formattedPoolData24h = parsePoolData(data?.oneDayAgo)\n        const formattedPoolData48h = parsePoolData(data?.twoDaysAgo)\n        const formattedPoolData7d = parsePoolData(data?.oneWeekAgo)\n        const formattedPoolData14d = parsePoolData(data?.twoWeeksAgo)\n\n        // Calculate data and format\n        const formatted = poolAddresses.reduce((accum: { [address: string]: PoolData }, address) => {\n          // Undefined data is possible if pool is brand new and didn't exist one day ago or week ago.\n          const current: FormattedPoolFields | undefined = formattedPoolData[address]\n          const oneDay: FormattedPoolFields | undefined = formattedPoolData24h[address]\n          const twoDays: FormattedPoolFields | undefined = formattedPoolData48h[address]\n          const week: FormattedPoolFields | undefined = formattedPoolData7d[address]\n          const twoWeeks: FormattedPoolFields | undefined = formattedPoolData14d[address]\n\n          const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n            current?.volumeUSD,\n            oneDay?.volumeUSD,\n            twoDays?.volumeUSD,\n          )\n          const [volumeUSDWeek, volumeUSDChangeWeek] = getChangeForPeriod(\n            current?.volumeUSD,\n            week?.volumeUSD,\n            twoWeeks?.volumeUSD,\n          )\n\n          const liquidityUSD = current ? current.reserveUSD : 0\n\n          const liquidityUSDChange = getPercentChange(current?.reserveUSD, oneDay?.reserveUSD)\n\n          const liquidityToken0 = current ? current.reserve0 : 0\n          const liquidityToken1 = current ? current.reserve1 : 0\n\n          const { totalFees24h, totalFees7d, lpFees24h, lpFees7d, lpApr7d } = getLpFeesAndApr(\n            volumeUSD,\n            volumeUSDWeek,\n            liquidityUSD,\n          )\n\n          if (current) {\n            accum[address] = {\n              address,\n              token0: {\n                address: current.token0.id,\n                name: current.token0.name,\n                symbol: current.token0.symbol,\n              },\n              token1: {\n                address: current.token1.id,\n                name: current.token1.name,\n                symbol: current.token1.symbol,\n              },\n              token0Price: current.token0Price,\n              token1Price: current.token1Price,\n              volumeUSD,\n              volumeUSDChange,\n              volumeUSDWeek,\n              volumeUSDChangeWeek,\n              totalFees24h,\n              totalFees7d,\n              lpFees24h,\n              lpFees7d,\n              lpApr7d,\n              liquidityUSD,\n              liquidityUSDChange,\n              liquidityToken0,\n              liquidityToken1,\n            }\n          }\n\n          return accum\n        }, {})\n        setFetchState({ data: formatted, error: false })\n      }\n    }\n\n    const allBlocksAvailable = block24h?.number && block48h?.number && block7d?.number && block14d?.number\n    if (poolAddresses.length > 0 && allBlocksAvailable && !blockError) {\n      fetch()\n    }\n  }, [poolAddresses, block24h, block48h, block7d, block14d, blockError, chainName])\n\n  return fetchState\n}\n\nexport const fetchAllPoolDataWithAddress = async (\n  blocks: Block[],\n  chainName: MultiChainName,\n  poolAddresses: string[],\n) => {\n  const [block24h, block48h, block7d, block14d] = blocks ?? []\n\n  const { data } = await fetchPoolData(\n    block24h.number,\n    block48h.number,\n    block7d.number,\n    block14d.number,\n    poolAddresses,\n    chainName,\n  )\n\n  const formattedPoolData = parsePoolData(data?.now)\n  const formattedPoolData24h = parsePoolData(data?.oneDayAgo)\n  const formattedPoolData48h = parsePoolData(data?.twoDaysAgo)\n  const formattedPoolData7d = parsePoolData(data?.oneWeekAgo)\n  const formattedPoolData14d = parsePoolData(data?.twoWeeksAgo)\n\n  // Calculate data and format\n  const formatted = poolAddresses.reduce((accum: { [address: string]: { data: PoolData } }, address) => {\n    // Undefined data is possible if pool is brand new and didn't exist one day ago or week ago.\n    const current: FormattedPoolFields | undefined = formattedPoolData[address]\n    const oneDay: FormattedPoolFields | undefined = formattedPoolData24h[address]\n    const twoDays: FormattedPoolFields | undefined = formattedPoolData48h[address]\n    const week: FormattedPoolFields | undefined = formattedPoolData7d[address]\n    const twoWeeks: FormattedPoolFields | undefined = formattedPoolData14d[address]\n\n    const [volumeUSD, volumeUSDChange] = getChangeForPeriod(current?.volumeUSD, oneDay?.volumeUSD, twoDays?.volumeUSD)\n    const volumeOutUSD = current?.volumeOutUSD && getAmountChange(current?.volumeOutUSD, oneDay?.volumeOutUSD)\n    const volumeOutUSDWeek = current?.volumeOutUSD && getAmountChange(current?.volumeOutUSD, week?.volumeOutUSD)\n    const [volumeUSDWeek, volumeUSDChangeWeek] = getChangeForPeriod(\n      current?.volumeUSD,\n      week?.volumeUSD,\n      twoWeeks?.volumeUSD,\n    )\n\n    const liquidityUSD = current ? current.reserveUSD : 0\n\n    const liquidityUSDChange = getPercentChange(current?.reserveUSD, oneDay?.reserveUSD)\n\n    const liquidityToken0 = current ? current.reserve0 : 0\n    const liquidityToken1 = current ? current.reserve1 : 0\n\n    const { totalFees24h, totalFees7d, lpFees24h, lpFees7d, lpApr7d } = getLpFeesAndApr(\n      volumeUSD,\n      volumeUSDWeek,\n      liquidityUSD,\n    )\n\n    if (current) {\n      accum[address] = {\n        data: {\n          address,\n          token0: {\n            address: current.token0.id,\n            name: current.token0.name,\n            symbol: current.token0.symbol,\n          },\n          token1: {\n            address: current.token1.id,\n            name: current.token1.name,\n            symbol: current.token1.symbol,\n          },\n          token0Price: current.token0Price,\n          token1Price: current.token1Price,\n          volumeUSD,\n          volumeUSDChange,\n          volumeUSDWeek,\n          volumeUSDChangeWeek,\n          totalFees24h,\n          totalFees7d,\n          lpFees24h,\n          lpFees7d,\n          lpApr7d,\n          liquidityUSD,\n          liquidityUSDChange,\n          liquidityToken0,\n          liquidityToken1,\n          volumeOutUSD,\n          volumeOutUSDWeek,\n        },\n      }\n    }\n\n    return accum\n  }, {})\n  return formatted\n}\n\nexport const fetchAllPoolData = async (blocks: Block[], chainName: MultiChainName) => {\n  const poolAddresses = await fetchTopPoolAddresses(chainName)\n  return fetchAllPoolDataWithAddress(blocks, chainName, poolAddresses)\n}\n\nexport default usePoolDatas\n","import { gql } from 'graphql-request'\nimport { mapBurns, mapMints, mapSwaps } from 'state/info/queries/helpers'\nimport { BurnResponse, MintResponse, SwapResponse } from 'state/info/queries/types'\nimport { Transaction } from 'state/info/types'\nimport { MultiChainName, getMultiChainQueryEndPointWithStableSwap } from '../../constant'\n/**\n * Transactions of the given pool, used on Pool page\n */\nconst POOL_TRANSACTIONS = gql`\n  query poolTransactions($address: ID!) {\n    mints(first: 35, orderBy: timestamp, orderDirection: desc, where: { pair: $address }) {\n      id\n      timestamp\n      to\n      amount0\n      amount1\n      amountUSD\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n    }\n    swaps(first: 35, orderBy: timestamp, orderDirection: desc, where: { pair: $address }) {\n      id\n      timestamp\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n    }\n    burns(first: 35, orderBy: timestamp, orderDirection: desc, where: { pair: $address }) {\n      id\n      timestamp\n      sender\n      amount0\n      amount1\n      amountUSD\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n    }\n  }\n`\n\ninterface TransactionResults {\n  mints: MintResponse[]\n  swaps: SwapResponse[]\n  burns: BurnResponse[]\n}\n\nconst fetchPoolTransactions = async (\n  chainName: MultiChainName,\n  address: string,\n): Promise<{ data?: Transaction[]; error: boolean }> => {\n  try {\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TransactionResults>(\n      POOL_TRANSACTIONS,\n      {\n        address,\n      },\n    )\n    const mints = data.mints.map(mapMints)\n    const burns = data.burns.map(mapBurns)\n    const swaps = data.swaps.map(mapSwaps)\n    return { data: [...mints, ...burns, ...swaps], error: false }\n  } catch (error) {\n    console.error(`Failed to fetch transactions for pool ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchPoolTransactions\n","/* eslint-disable no-await-in-loop */\nimport { gql } from 'graphql-request'\nimport { useEffect, useState } from 'react'\nimport { ChartEntry } from 'state/info/types'\nimport { fetchChartData, mapDayData } from '../helpers'\nimport { PancakeDayDatasResponse } from '../types'\nimport { MultiChainName, getMultiChainQueryEndPointWithStableSwap, multiChainStartTime } from '../../constant'\nimport { useGetChainName } from '../../hooks'\n\n/**\n * Data for displaying Liquidity and Volume charts on Overview page\n */\nconst PANCAKE_DAY_DATAS = gql`\n  query overviewCharts($startTime: Int!, $skip: Int!) {\n    pancakeDayDatas(first: 1000, skip: $skip, where: { date_gt: $startTime }, orderBy: date, orderDirection: asc) {\n      date\n      dailyVolumeUSD\n      totalLiquidityUSD\n    }\n  }\n`\n\nconst getOverviewChartData = async (\n  chainName: MultiChainName,\n  skip: number,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  try {\n    const { pancakeDayDatas } = await getMultiChainQueryEndPointWithStableSwap(\n      chainName,\n    ).request<PancakeDayDatasResponse>(PANCAKE_DAY_DATAS, {\n      startTime: multiChainStartTime[chainName],\n      skip,\n    })\n    const data = pancakeDayDatas.map(mapDayData)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch overview chart data', error)\n    return { error: true }\n  }\n}\n\n/**\n * Fetch historic chart data\n */\nconst useFetchGlobalChartData = (): {\n  error: boolean\n  data: ChartEntry[] | undefined\n} => {\n  const [overviewChartData, setOverviewChartData] = useState<ChartEntry[] | undefined>()\n  const [error, setError] = useState(false)\n  const chainName = useGetChainName()\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { data } = await fetchChartData(chainName, getOverviewChartData)\n      if (data) {\n        setOverviewChartData(data)\n      } else {\n        setError(true)\n      }\n    }\n    if (!overviewChartData && !error) {\n      fetch()\n    }\n  }, [overviewChartData, error, chainName])\n\n  return {\n    error,\n    data: overviewChartData,\n  }\n}\n\nexport const fetchGlobalChartData = async (chainName: MultiChainName) => {\n  const { data } = await fetchChartData(chainName, getOverviewChartData)\n  return data\n}\n\nexport default useFetchGlobalChartData\n","/* eslint-disable no-param-reassign */\nimport { gql } from 'graphql-request'\nimport { useEffect, useState } from 'react'\nimport { Block, ProtocolData } from 'state/info/types'\nimport { getChangeForPeriod } from 'utils/getChangeForPeriod'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { getPercentChange } from 'views/Info/utils/infoDataHelpers'\nimport { checkIsStableSwap, getMultiChainQueryEndPointWithStableSwap, MultiChainName } from '../../constant'\nimport { useGetChainName } from '../../hooks'\n\ninterface PancakeFactory {\n  totalTransactions: string\n  totalVolumeUSD: string\n  totalLiquidityUSD: string\n}\n\ninterface OverviewResponse {\n  pancakeFactories: PancakeFactory[]\n  factories?: PancakeFactory[]\n}\n/**\n * Latest Liquidity, Volume and Transaction count\n */\nconst getOverviewData = async (\n  chainName: MultiChainName,\n  block?: number,\n): Promise<{ data?: OverviewResponse; error: boolean }> => {\n  const factoryString = checkIsStableSwap() ? `factories` : `pancakeFactories`\n  try {\n    const query = gql`query overview {\n      ${factoryString}(\n        ${block ? `block: { number: ${block}}` : ``}\n        first: 5) {\n        totalTransactions\n        totalVolumeUSD\n        totalLiquidityUSD\n      }\n    }`\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<OverviewResponse>(query)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch info overview', error)\n    return { data: null, error: true }\n  }\n}\n\nconst formatPancakeFactoryResponse = (rawPancakeFactory?: PancakeFactory[]) => {\n  if (rawPancakeFactory) {\n    return rawPancakeFactory.reduce(\n      (acc, cur) => {\n        acc.totalLiquidityUSD += parseFloat(cur.totalLiquidityUSD)\n        acc.totalTransactions += parseFloat(cur.totalTransactions)\n        acc.totalVolumeUSD += parseFloat(cur.totalVolumeUSD)\n        return acc\n      },\n      {\n        totalLiquidityUSD: 0,\n        totalTransactions: 0,\n        totalVolumeUSD: 0,\n      },\n    )\n  }\n  return null\n}\n\ninterface ProtocolFetchState {\n  error: boolean\n  data?: ProtocolData\n}\n\nconst useFetchProtocolData = (): ProtocolFetchState => {\n  const [fetchState, setFetchState] = useState<ProtocolFetchState>({\n    error: false,\n  })\n  const [t24, t48] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24, t48])\n  const [block24, block48] = blocks ?? []\n  const chainName = useGetChainName()\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const [{ error, data }, { error: error24, data: data24 }, { error: error48, data: data48 }] = await Promise.all([\n        getOverviewData(chainName),\n        getOverviewData(chainName, block24?.number ?? undefined),\n        getOverviewData(chainName, block48?.number ?? undefined),\n      ])\n      const anyError = error || error24 || error48\n      const overviewData = formatPancakeFactoryResponse(data?.pancakeFactories)\n      const overviewData24 = formatPancakeFactoryResponse(data24?.pancakeFactories)\n      const overviewData48 = formatPancakeFactoryResponse(data48?.pancakeFactories)\n      const allDataAvailable = overviewData && overviewData24 && overviewData48\n      if (anyError || !allDataAvailable) {\n        setFetchState({\n          error: true,\n        })\n      } else {\n        const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n          overviewData.totalVolumeUSD,\n          overviewData24.totalVolumeUSD,\n          overviewData48.totalVolumeUSD,\n        )\n        const liquidityUSDChange = getPercentChange(overviewData.totalLiquidityUSD, overviewData24.totalLiquidityUSD)\n        // 24H transactions\n        const [txCount, txCountChange] = getChangeForPeriod(\n          overviewData.totalTransactions,\n          overviewData24.totalTransactions,\n          overviewData48.totalTransactions,\n        )\n        const protocolData: ProtocolData = {\n          volumeUSD,\n          volumeUSDChange: typeof volumeUSDChange === 'number' ? volumeUSDChange : 0,\n          liquidityUSD: overviewData.totalLiquidityUSD,\n          liquidityUSDChange,\n          txCount,\n          txCountChange,\n        }\n        setFetchState({\n          error: false,\n          data: protocolData,\n        })\n      }\n    }\n\n    const allBlocksAvailable = block24?.number && block48?.number\n    if (allBlocksAvailable && !blockError && !fetchState.data) {\n      fetchData()\n    }\n  }, [block24, block48, blockError, fetchState, chainName])\n\n  return fetchState\n}\n\nexport const fetchProtocolData = async (chainName: MultiChainName, block24: Block, block48: Block) => {\n  const [{ data }, { data: data24 }, { data: data48 }] = await Promise.all([\n    getOverviewData(chainName),\n    getOverviewData(chainName, block24?.number ?? undefined),\n    getOverviewData(chainName, block48?.number ?? undefined),\n  ])\n  if (data.factories && data.factories.length > 0) data.pancakeFactories = data.factories\n  if (data24.factories && data24.factories.length > 0) data24.pancakeFactories = data24.factories\n  if (data48.factories && data48.factories.length > 0) data48.pancakeFactories = data48.factories\n\n  // const anyError = error || error24 || error48\n  const overviewData = formatPancakeFactoryResponse(data?.pancakeFactories)\n  const overviewData24 = formatPancakeFactoryResponse(data24?.pancakeFactories)\n  const overviewData48 = formatPancakeFactoryResponse(data48?.pancakeFactories)\n  // const allDataAvailable = overviewData && overviewData24 && overviewData48\n\n  const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n    overviewData.totalVolumeUSD,\n    overviewData24.totalVolumeUSD,\n    overviewData48.totalVolumeUSD,\n  )\n  const liquidityUSDChange = getPercentChange(overviewData.totalLiquidityUSD, overviewData24.totalLiquidityUSD)\n  // 24H transactions\n  const [txCount, txCountChange] = getChangeForPeriod(\n    overviewData.totalTransactions,\n    overviewData24.totalTransactions,\n    overviewData48.totalTransactions,\n  )\n  const protocolData: ProtocolData = {\n    volumeUSD,\n    volumeUSDChange: typeof volumeUSDChange === 'number' ? volumeUSDChange : 0,\n    liquidityUSD: overviewData.totalLiquidityUSD,\n    liquidityUSDChange,\n    txCount,\n    txCountChange,\n  }\n  return protocolData\n}\n\nexport default useFetchProtocolData\n","import { gql } from 'graphql-request'\nimport { mapBurns, mapMints, mapSwaps } from 'state/info/queries/helpers'\nimport { BurnResponse, MintResponse, SwapResponse } from 'state/info/queries/types'\nimport { Transaction } from 'state/info/types'\nimport { getMultiChainQueryEndPointWithStableSwap, MultiChainName } from '../../constant'\n\n/**\n * Transactions for Transaction table on the Home page\n */\nconst GLOBAL_TRANSACTIONS = gql`\n  query overviewTransactions {\n    mints: mints(first: 33, orderBy: timestamp, orderDirection: desc) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    swaps: swaps(first: 33, orderBy: timestamp, orderDirection: desc) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    burns: burns(first: 33, orderBy: timestamp, orderDirection: desc) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n  }\n`\n\ninterface TransactionResults {\n  mints: MintResponse[]\n  swaps: SwapResponse[]\n  burns: BurnResponse[]\n}\n\nconst fetchTopTransactions = async (chainName: MultiChainName): Promise<Transaction[] | undefined> => {\n  try {\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TransactionResults>(\n      GLOBAL_TRANSACTIONS,\n    )\n    if (!data) {\n      return undefined\n    }\n\n    const mints = data.mints.map(mapMints)\n    const burns = data.burns.map(mapBurns)\n    const swaps = data.swaps.map(mapSwaps)\n\n    return [...mints, ...burns, ...swaps].sort((a, b) => {\n      return parseInt(b.timestamp, 10) - parseInt(a.timestamp, 10)\n    })\n  } catch {\n    return undefined\n  }\n}\n\nexport default fetchTopTransactions\n","import { gql } from 'graphql-request'\nimport { ChartEntry } from 'state/info/types'\nimport { fetchChartDataWithAddress, mapDayData } from '../helpers'\nimport { TokenDayDatasResponse } from '../types'\nimport { getMultiChainQueryEndPointWithStableSwap, MultiChainName, multiChainStartTime } from '../../constant'\n\nconst getTokenChartData = async (\n  chainName: MultiChainName,\n  skip: number,\n  address: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  try {\n    const query = gql`\n      query tokenDayDatas($startTime: Int!, $skip: Int!, $address: String!) {\n        tokenDayDatas(\n          first: 1000\n          skip: $skip\n          where: { token: $address, date_gt: $startTime }\n          orderBy: date\n          orderDirection: asc\n        ) {\n          date\n          dailyVolumeUSD\n          totalLiquidityUSD\n        }\n      }\n    `\n    const { tokenDayDatas } = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TokenDayDatasResponse>(\n      query,\n      {\n        startTime: multiChainStartTime[chainName],\n        skip,\n        address,\n      },\n    )\n    const data = tokenDayDatas.map(mapDayData)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch token chart data', error)\n    return { error: true }\n  }\n}\n\nconst fetchTokenChartData = async (\n  chainName: MultiChainName,\n  address: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  return fetchChartDataWithAddress(chainName, getTokenChartData, address)\n}\n\nexport default fetchTokenChartData\n","import { TOKEN_BLACKLIST } from 'config/constants/info'\nimport { gql } from 'graphql-request'\nimport { MultiChainName, multiChainQueryMainToken, getMultiChainQueryEndPointWithStableSwap } from '../../constant'\n\n/**\n * Data for showing Pools table on the Token page\n */\nconst POOLS_FOR_TOKEN = (chainName: MultiChainName) => {\n  const transactionGT = chainName === 'ETH' ? 1 : 100\n  return gql`\n  query poolsForToken($address: String!, $blacklist: [String!]) {\n    asToken0: pairs(\n      first: 15\n      orderBy: trackedReserve${multiChainQueryMainToken[chainName]}\n      orderDirection: desc\n      where: { totalTransactions_gt: ${transactionGT}, token0: $address, token1_not_in: $blacklist }\n    ) {\n      id\n    }\n    asToken1: pairs(\n      first: 15\n      orderBy: trackedReserve${multiChainQueryMainToken[chainName]}\n      orderDirection: desc\n      where: { totalTransactions_gt: ${transactionGT}, token1: $address, token0_not_in: $blacklist }\n    ) {\n      id\n    }\n  }\n`\n}\n\nexport interface PoolsForTokenResponse {\n  asToken0: {\n    id: string\n  }[]\n  asToken1: {\n    id: string\n  }[]\n}\n\nconst fetchPoolsForToken = async (\n  chainName: MultiChainName,\n  address: string,\n): Promise<{\n  error: boolean\n  addresses?: string[]\n}> => {\n  try {\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<PoolsForTokenResponse>(\n      POOLS_FOR_TOKEN(chainName),\n      {\n        address,\n        blacklist: TOKEN_BLACKLIST,\n      },\n    )\n    return {\n      error: false,\n      addresses: data.asToken0\n        .concat(data.asToken1)\n        .map((p) => p.id)\n        .map((d) => d.toLowerCase()),\n    }\n  } catch (error) {\n    console.error(`Failed to fetch pools for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchPoolsForToken\n","import { getUnixTime } from 'date-fns'\nimport { gql } from 'graphql-request'\nimport orderBy from 'lodash/orderBy'\n\nimport { PriceChartEntry } from 'state/info/types'\nimport { getBlocksFromTimestamps } from 'utils/getBlocksFromTimestamps'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { MultiChainName, multiChainQueryEndPoint, multiChainQueryMainToken, checkIsStableSwap } from '../../constant'\n\nconst getPriceSubqueries = (chainName: MultiChainName, tokenAddress: string, blocks: any) =>\n  blocks.map(\n    (block: any) => `\n      t${block.timestamp}:token(id:\"${tokenAddress}\", block: { number: ${block.number} }) {\n        derived${multiChainQueryMainToken[chainName]}\n      }\n      b${block.timestamp}: bundle(id:\"1\", block: { number: ${block.number} }) {\n        ${multiChainQueryMainToken[chainName].toLowerCase()}Price\n      }\n    `,\n  )\n\n/**\n * Price data for token and bnb based on block number\n */\nconst priceQueryConstructor = (subqueries: string[]) => {\n  return gql`\n    query tokenPriceData {\n      ${subqueries}\n    }\n  `\n}\n\nconst fetchTokenPriceData = async (\n  chainName: MultiChainName,\n  address: string,\n  interval: number,\n  startTimestamp: number,\n): Promise<{\n  data?: PriceChartEntry[]\n  error: boolean\n}> => {\n  // Construct timestamps to query against\n  const endTimestamp = getUnixTime(new Date())\n  const timestamps = []\n  let time = startTimestamp\n  while (time <= endTimestamp) {\n    timestamps.push(time)\n    time += interval\n  }\n  try {\n    const blocks = await getBlocksFromTimestamps(timestamps, 'asc', 500, chainName)\n    const blocksLength = blocks?.length ?? 0\n    if (blocksLength > 0 && chainName === 'BSC' && !checkIsStableSwap()) {\n      const data = blocks[blocksLength - 1]\n      blocks[blocksLength - 1] = { timestamp: data.timestamp, number: data.number - 32 }\n      // nodeReal will sync the the 32 block before latest\n    }\n    if (!blocks || blocksLength === 0) {\n      console.error('Error fetching blocks for timestamps', timestamps)\n      return {\n        error: false,\n      }\n    }\n\n    const prices: any | undefined = await multiQuery(\n      priceQueryConstructor,\n      getPriceSubqueries(chainName, address, blocks),\n      multiChainQueryEndPoint[chainName],\n      200,\n    )\n\n    console.warn('fetchTokenPriceData', { chainName, prices })\n\n    if (!prices) {\n      console.error('Price data failed to load')\n      return {\n        error: false,\n      }\n    }\n\n    // format token BNB price results\n    const tokenPrices: {\n      timestamp: string\n      derivedBNB: number\n      priceUSD: number\n    }[] = []\n\n    const mainToken = multiChainQueryMainToken[chainName]\n\n    // Get Token prices in BNB\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('t')[1]\n      // if its BNB price e.g. `b123` split('t')[1] will be undefined and skip BNB price entry\n      if (timestamp) {\n        tokenPrices.push({\n          timestamp,\n          derivedBNB: prices[priceKey]?.[`derived${mainToken}`]\n            ? parseFloat(prices[priceKey][`derived${mainToken}`])\n            : 0,\n          priceUSD: 0,\n        })\n      }\n    })\n\n    console.warn('pricesPart1', tokenPrices)\n\n    // Go through BNB USD prices and calculate Token price based on it\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('b')[1]\n      // if its Token price e.g. `t123` split('b')[1] will be undefined and skip Token price entry\n      if (timestamp) {\n        const tokenPriceIndex = tokenPrices.findIndex((tokenPrice) => tokenPrice.timestamp === timestamp)\n        if (tokenPriceIndex >= 0) {\n          const { derivedBNB } = tokenPrices[tokenPriceIndex]\n          tokenPrices[tokenPriceIndex].priceUSD =\n            parseFloat(prices[priceKey]?.[`${mainToken.toLowerCase()}Price`] ?? 0) * derivedBNB\n        }\n      }\n    })\n\n    // graphql-request does not guarantee same ordering of batched requests subqueries, hence sorting by timestamp from oldest to newest\n    const sortedTokenPrices = orderBy(tokenPrices, (tokenPrice) => parseInt(tokenPrice.timestamp, 10))\n\n    const formattedHistory = []\n\n    // for each timestamp, construct the open and close price\n    for (let i = 0; i < sortedTokenPrices.length - 1; i++) {\n      formattedHistory.push({\n        time: parseFloat(sortedTokenPrices[i].timestamp),\n        open: sortedTokenPrices[i].priceUSD,\n        close: sortedTokenPrices[i + 1].priceUSD,\n        high: sortedTokenPrices[i + 1].priceUSD,\n        low: sortedTokenPrices[i].priceUSD,\n      })\n    }\n\n    return { data: formattedHistory, error: false }\n  } catch (error) {\n    console.error(`Failed to fetch price data for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenPriceData\n","import { gql } from 'graphql-request'\nimport { useCallback, useState, useEffect } from 'react'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport union from 'lodash/union'\nimport { useGetChainName } from '../../hooks'\nimport {\n  MultiChainName,\n  getMultiChainQueryEndPointWithStableSwap,\n  checkIsStableSwap,\n  multiChainTokenBlackList,\n  multiChainTokenWhiteList,\n} from '../../constant'\n\ninterface TopTokensResponse {\n  tokenDayDatas: {\n    id: string\n  }[]\n}\n\ninterface StableSwapTopTokensResponse {\n  tokens: {\n    id: string\n  }[]\n}\n\n/**\n * Tokens to display on Home page\n * The actual data is later requested in tokenData.ts\n * Note: dailyTxns_gt: 300 is there to prevent fetching incorrectly priced tokens with high dailyVolumeUSD\n */\nconst fetchTopTokens = async (chainName: MultiChainName, timestamp24hAgo: number): Promise<string[]> => {\n  const whereCondition =\n    chainName === 'ETH'\n      ? `where: { date_gt: ${timestamp24hAgo}, token_not_in: $blacklist, dailyVolumeUSD_gt:2000 }`\n      : checkIsStableSwap()\n      ? ''\n      : `where: { dailyTxns_gt: 300, id_not_in: $blacklist, date_gt: ${timestamp24hAgo}}`\n  const firstCount = 50\n  try {\n    const query = gql`\n      query topTokens($blacklist: [ID!]) {\n        tokenDayDatas(\n          first: ${firstCount}\n          ${whereCondition}\n          orderBy: dailyVolumeUSD\n          orderDirection: desc\n        ) {\n          id\n        }\n      }\n    `\n\n    const stableSwapQuery = gql`\n      query topTokens {\n        tokens(\n          first: ${firstCount}\n          ${whereCondition}\n          orderBy: totalLiquidity\n          orderDirection: desc\n        ) {\n          id\n        }\n      }\n    `\n\n    if (checkIsStableSwap()) {\n      const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<StableSwapTopTokensResponse>(\n        stableSwapQuery,\n      )\n      return union(\n        data.tokens.map((t) => t.id),\n        multiChainTokenWhiteList[chainName],\n      )\n    }\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TopTokensResponse>(query, {\n      blacklist: multiChainTokenBlackList[chainName],\n    })\n    // tokenDayDatas id has compound id \"0xTOKENADDRESS-NUMBERS\", extracting token address with .split('-')\n    return union(\n      data.tokenDayDatas.map((t) => t.id.split('-')[0]),\n      multiChainTokenWhiteList[chainName],\n    )\n  } catch (error) {\n    console.warn('fetchTopTokens', { chainName, timestamp24hAgo })\n    console.error('Failed to fetch top tokens', error)\n    return []\n  }\n}\n\n/**\n * Fetch top addresses by volume\n */\nconst useTopTokenAddresses = (): string[] => {\n  const [topTokenAddresses, setTopTokenAddresses] = useState([])\n  const [timestamp24hAgo] = getDeltaTimestamps()\n  const chainName = useGetChainName()\n\n  const fetch = useCallback(async () => {\n    const addresses = await fetchTopTokens(chainName, timestamp24hAgo)\n    if (addresses.length > 0) setTopTokenAddresses(addresses)\n  }, [timestamp24hAgo, chainName])\n\n  useEffect(() => {\n    fetch()\n  }, [chainName, fetch])\n\n  return topTokenAddresses\n}\n\nexport const fetchTokenAddresses = async (chainName: MultiChainName) => {\n  const [timestamp24hAgo] = getDeltaTimestamps()\n\n  const addresses = await fetchTopTokens(chainName, timestamp24hAgo)\n\n  return addresses\n}\n\nexport default useTopTokenAddresses\n","/* eslint-disable no-param-reassign */\nimport { gql } from 'graphql-request'\nimport { useEffect, useState } from 'react'\nimport { TokenData, Block } from 'state/info/types'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport { getChangeForPeriod } from 'utils/getChangeForPeriod'\nimport { useBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { getAmountChange, getPercentChange } from 'views/Info/utils/infoDataHelpers'\nimport { getMultiChainQueryEndPointWithStableSwap, MultiChainName, multiChainQueryMainToken } from '../../constant'\nimport { fetchTokenAddresses } from './topTokens'\n\ninterface TokenFields {\n  id: string\n  symbol: string\n  name: string\n  decimals: string\n  derivedBNB: string // Price in BNB per token\n  derivedETH: string // Price in ETH per token\n  derivedUSD: string // Price in USD per token\n  tradeVolumeUSD: string\n  totalTransactions: string\n  totalLiquidity: string\n}\n\ninterface FormattedTokenFields\n  extends Omit<\n    TokenFields,\n    'derivedETH' | 'derivedBNB' | 'derivedUSD' | 'tradeVolumeUSD' | 'totalTransactions' | 'totalLiquidity' | 'decimals'\n  > {\n  derivedBNB: number\n  derivedETH: number\n  derivedUSD: number\n  tradeVolumeUSD: number\n  totalTransactions: number\n  totalLiquidity: number\n  decimals: number\n}\n\ninterface TokenQueryResponse {\n  now: TokenFields[]\n  oneDayAgo: TokenFields[]\n  twoDaysAgo: TokenFields[]\n  oneWeekAgo: TokenFields[]\n  twoWeeksAgo: TokenFields[]\n}\n\n/**\n * Main token data to display on Token page\n */\nconst TOKEN_AT_BLOCK = (chainName: MultiChainName, block: number | undefined, tokens: string[]) => {\n  const addressesString = `[\"${tokens.join('\",\"')}\"]`\n  const blockString = block ? `block: {number: ${block}}` : ``\n  return `tokens(\n      where: {id_in: ${addressesString}}\n      ${blockString}\n      orderBy: tradeVolumeUSD\n      orderDirection: desc\n    ) {\n      id\n      symbol\n      name\n      decimals\n      derived${multiChainQueryMainToken[chainName]}\n      derivedUSD\n      tradeVolumeUSD\n      totalTransactions\n      totalLiquidity\n    }\n  `\n}\n\nconst fetchTokenData = async (\n  chainName: MultiChainName,\n  block24h: number,\n  block48h: number,\n  block7d: number,\n  block14d: number,\n  tokenAddresses: string[],\n) => {\n  try {\n    const query = gql`\n      query tokens {\n        now: ${TOKEN_AT_BLOCK(chainName, null, tokenAddresses)}\n        oneDayAgo: ${TOKEN_AT_BLOCK(chainName, block24h, tokenAddresses)}\n        twoDaysAgo: ${TOKEN_AT_BLOCK(chainName, block48h, tokenAddresses)}\n        oneWeekAgo: ${TOKEN_AT_BLOCK(chainName, block7d, tokenAddresses)}\n        twoWeeksAgo: ${TOKEN_AT_BLOCK(chainName, block14d, tokenAddresses)}\n      }\n    `\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TokenQueryResponse>(query)\n    return { data, error: false }\n  } catch (error) {\n    console.error('Failed to fetch token data', error)\n    return { error: true }\n  }\n}\n\n// Transforms tokens into \"0xADDRESS: { ...TokenFields }\" format and cast strings to numbers\nconst parseTokenData = (tokens?: TokenFields[]) => {\n  if (!tokens) {\n    return {}\n  }\n  return tokens.reduce((accum: { [address: string]: FormattedTokenFields }, tokenData) => {\n    const { derivedBNB, derivedUSD, tradeVolumeUSD, totalTransactions, totalLiquidity, derivedETH, decimals } =\n      tokenData\n    accum[tokenData.id.toLowerCase()] = {\n      ...tokenData,\n      derivedBNB: derivedBNB ? 0 : parseFloat(derivedBNB),\n      derivedETH: derivedETH ? 0 : parseFloat(derivedETH),\n      derivedUSD: parseFloat(derivedUSD),\n      tradeVolumeUSD: parseFloat(tradeVolumeUSD),\n      totalTransactions: parseFloat(totalTransactions),\n      totalLiquidity: parseFloat(totalLiquidity),\n      decimals: parseInt(decimals),\n    }\n    return accum\n  }, {})\n}\n\ninterface TokenDatas {\n  error: boolean\n  data?: {\n    [address: string]: TokenData\n  }\n}\n\n/**\n * Fetch top addresses by volume\n */\nconst useFetchedTokenDatas = (chainName: MultiChainName, tokenAddresses: string[]): TokenDatas => {\n  const [fetchState, setFetchState] = useState<TokenDatas>({ error: false })\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks, error: blockError } = useBlocksFromTimestamps([t24h, t48h, t7d, t14d])\n  const [block24h, block48h, block7d, block14d] = blocks ?? []\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error, data } = await fetchTokenData(\n        chainName,\n        block24h.number,\n        block48h.number,\n        block7d.number,\n        block14d.number,\n        tokenAddresses,\n      )\n\n      if (error) {\n        setFetchState({ error: true })\n      } else {\n        const parsed = parseTokenData(data?.now)\n        const parsed24 = parseTokenData(data?.oneDayAgo)\n        const parsed48 = parseTokenData(data?.twoDaysAgo)\n        const parsed7d = parseTokenData(data?.oneWeekAgo)\n        const parsed14d = parseTokenData(data?.twoWeeksAgo)\n\n        // Calculate data and format\n        const formatted = tokenAddresses.reduce((accum: { [address: string]: TokenData }, address) => {\n          const current: FormattedTokenFields | undefined = parsed[address]\n          const oneDay: FormattedTokenFields | undefined = parsed24[address]\n          const twoDays: FormattedTokenFields | undefined = parsed48[address]\n          const week: FormattedTokenFields | undefined = parsed7d[address]\n          const twoWeeks: FormattedTokenFields | undefined = parsed14d[address]\n\n          const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n            current?.tradeVolumeUSD,\n            oneDay?.tradeVolumeUSD,\n            twoDays?.tradeVolumeUSD,\n          )\n          const [volumeUSDWeek] = getChangeForPeriod(\n            current?.tradeVolumeUSD,\n            week?.tradeVolumeUSD,\n            twoWeeks?.tradeVolumeUSD,\n          )\n          const liquidityUSD = current ? current.totalLiquidity * current.derivedUSD : 0\n          const liquidityUSDOneDayAgo = oneDay ? oneDay.totalLiquidity * oneDay.derivedUSD : 0\n          const liquidityUSDChange = getPercentChange(liquidityUSD, liquidityUSDOneDayAgo)\n          const liquidityToken = current ? current.totalLiquidity : 0\n          // Prices of tokens for now, 24h ago and 7d ago\n          const priceUSD = current ? current.derivedUSD : 0\n          const priceUSDOneDay = oneDay ? oneDay.derivedUSD : 0\n          const priceUSDWeek = week ? week.derivedUSD : 0\n          const priceUSDChange = getPercentChange(priceUSD, priceUSDOneDay)\n          const priceUSDChangeWeek = getPercentChange(priceUSD, priceUSDWeek)\n          const txCount = getAmountChange(current?.totalTransactions, oneDay?.totalTransactions)\n\n          accum[address] = {\n            exists: !!current,\n            address,\n            name: current ? current.name : '',\n            symbol: current ? current.symbol : '',\n            volumeUSD,\n            volumeUSDChange,\n            volumeUSDWeek,\n            txCount,\n            liquidityUSD,\n            liquidityUSDChange,\n            liquidityToken,\n            priceUSD,\n            priceUSDChange,\n            priceUSDChangeWeek,\n            decimals: current ? current.decimals : 18,\n          }\n\n          return accum\n        }, {})\n        setFetchState({ data: formatted, error: false })\n      }\n    }\n    const allBlocksAvailable = block24h?.number && block48h?.number && block7d?.number && block14d?.number\n    if (tokenAddresses.length > 0 && allBlocksAvailable && !blockError) {\n      fetch()\n    }\n  }, [tokenAddresses, block24h, block48h, block7d, block14d, blockError, chainName])\n\n  return fetchState\n}\n\nexport const fetchAllTokenDataByAddresses = async (\n  chainName: MultiChainName,\n  blocks: Block[],\n  tokenAddresses: string[],\n) => {\n  const [block24h, block48h, block7d, block14d] = blocks ?? []\n\n  const { data } = await fetchTokenData(\n    chainName,\n    block24h.number,\n    block48h.number,\n    block7d.number,\n    block14d.number,\n    tokenAddresses,\n  )\n\n  const parsed = parseTokenData(data?.now)\n  const parsed24 = parseTokenData(data?.oneDayAgo)\n  const parsed48 = parseTokenData(data?.twoDaysAgo)\n  const parsed7d = parseTokenData(data?.oneWeekAgo)\n  const parsed14d = parseTokenData(data?.twoWeeksAgo)\n\n  // Calculate data and format\n  const formatted = tokenAddresses.reduce((accum: { [address: string]: { data: TokenData } }, address) => {\n    const current: FormattedTokenFields | undefined = parsed[address]\n    const oneDay: FormattedTokenFields | undefined = parsed24[address]\n    const twoDays: FormattedTokenFields | undefined = parsed48[address]\n    const week: FormattedTokenFields | undefined = parsed7d[address]\n    const twoWeeks: FormattedTokenFields | undefined = parsed14d[address]\n\n    const [volumeUSD, volumeUSDChange] = getChangeForPeriod(\n      current?.tradeVolumeUSD,\n      oneDay?.tradeVolumeUSD,\n      twoDays?.tradeVolumeUSD,\n    )\n    const [volumeUSDWeek] = getChangeForPeriod(current?.tradeVolumeUSD, week?.tradeVolumeUSD, twoWeeks?.tradeVolumeUSD)\n    const liquidityUSD = current ? current.totalLiquidity * current.derivedUSD : 0\n    const liquidityUSDOneDayAgo = oneDay ? oneDay.totalLiquidity * oneDay.derivedUSD : 0\n    const liquidityUSDChange = getPercentChange(liquidityUSD, liquidityUSDOneDayAgo)\n    const liquidityToken = current ? current.totalLiquidity : 0\n    // Prices of tokens for now, 24h ago and 7d ago\n    const priceUSD = current ? current.derivedUSD : 0\n    const decimals = current ? current.decimals : 0\n    const priceUSDOneDay = oneDay ? oneDay.derivedUSD : 0\n    const priceUSDWeek = week ? week.derivedUSD : 0\n    const priceUSDChange = getPercentChange(priceUSD, priceUSDOneDay)\n    const priceUSDChangeWeek = getPercentChange(priceUSD, priceUSDWeek)\n    const txCount = getAmountChange(current?.totalTransactions, oneDay?.totalTransactions)\n\n    accum[address] = {\n      data: {\n        exists: !!current,\n        address,\n        name: current ? current.name : '',\n        symbol: current ? current.symbol : '',\n        volumeUSD,\n        volumeUSDChange,\n        volumeUSDWeek,\n        txCount,\n        liquidityUSD,\n        liquidityUSDChange,\n        liquidityToken,\n        priceUSD,\n        priceUSDChange,\n        priceUSDChangeWeek,\n        decimals,\n      },\n    }\n    return accum\n  }, {})\n\n  return formatted\n}\n\nexport const fetchAllTokenData = async (chainName: MultiChainName, blocks: Block[]) => {\n  const tokenAddresses = await fetchTokenAddresses(chainName)\n  const data = await fetchAllTokenDataByAddresses(chainName, blocks, tokenAddresses)\n  return data\n}\n\nexport default useFetchedTokenDatas\n","import { gql } from 'graphql-request'\nimport { mapBurns, mapMints, mapSwaps } from 'state/info/queries/helpers'\nimport { BurnResponse, MintResponse, SwapResponse } from 'state/info/queries/types'\nimport { Transaction } from 'state/info/types'\nimport { MultiChainName, getMultiChainQueryEndPointWithStableSwap, checkIsStableSwap } from '../../constant'\n\n/**\n * Data to display transaction table on Token page\n */\nconst TOKEN_TRANSACTIONS = () => {\n  const isStableSwap = checkIsStableSwap()\n  const whereToken0 = isStableSwap ? 'pair_: {token0: $address}' : 'token0: $address'\n  const whereToken1 = isStableSwap ? 'pair_: {token1: $address}' : 'token1: $address'\n  return gql`\n    query tokenTransactions($address: String!) {\n      mintsAs0: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { ${whereToken0} }) {\n        id\n        timestamp\n        pair {\n          token0 {\n            id\n            symbol\n          }\n          token1 {\n            id\n            symbol\n          }\n        }\n        to\n        amount0\n        amount1\n        amountUSD\n      }\n      mintsAs1: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { ${whereToken1} }) {\n        id\n        timestamp\n        pair {\n          token0 {\n            id\n            symbol\n          }\n          token1 {\n            id\n            symbol\n          }\n        }\n        to\n        amount0\n        amount1\n        amountUSD\n      }\n      swapsAs0: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { ${whereToken0} }) {\n        id\n        timestamp\n        pair {\n          token0 {\n            id\n            symbol\n          }\n          token1 {\n            id\n            symbol\n          }\n        }\n        from\n        amount0In\n        amount1In\n        amount0Out\n        amount1Out\n        amountUSD\n      }\n      swapsAs1: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { ${whereToken1} }) {\n        id\n        timestamp\n        pair {\n          token0 {\n            id\n            symbol\n          }\n          token1 {\n            id\n            symbol\n          }\n        }\n        from\n        amount0In\n        amount1In\n        amount0Out\n        amount1Out\n        amountUSD\n      }\n      burnsAs0: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { ${whereToken0} }) {\n        id\n        timestamp\n        pair {\n          token0 {\n            id\n            symbol\n          }\n          token1 {\n            id\n            symbol\n          }\n        }\n        sender\n        amount0\n        amount1\n        amountUSD\n      }\n      burnsAs1: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { ${whereToken1} }) {\n        id\n        timestamp\n        pair {\n          token0 {\n            id\n            symbol\n          }\n          token1 {\n            id\n            symbol\n          }\n        }\n        sender\n        amount0\n        amount1\n        amountUSD\n      }\n    }\n  `\n}\n\ninterface TransactionResults {\n  mintsAs0: MintResponse[]\n  mintsAs1: MintResponse[]\n  swapsAs0: SwapResponse[]\n  swapsAs1: SwapResponse[]\n  burnsAs0: BurnResponse[]\n  burnsAs1: BurnResponse[]\n}\n\nconst fetchTokenTransactions = async (\n  chainName: MultiChainName,\n  address: string,\n): Promise<{ data?: Transaction[]; error: boolean }> => {\n  try {\n    const data = await getMultiChainQueryEndPointWithStableSwap(chainName).request<TransactionResults>(\n      TOKEN_TRANSACTIONS(),\n      {\n        address,\n      },\n    )\n    const mints0 = data.mintsAs0.map(mapMints)\n    const mints1 = data.mintsAs1.map(mapMints)\n\n    const burns0 = data.burnsAs0.map(mapBurns)\n    const burns1 = data.burnsAs1.map(mapBurns)\n\n    const swaps0 = data.swapsAs0.map(mapSwaps)\n    const swaps1 = data.swapsAs1.map(mapSwaps)\n\n    return { data: [...mints0, ...mints1, ...burns0, ...burns1, ...swaps0, ...swaps1], error: false }\n  } catch (error) {\n    console.error(`Failed to fetch transactions for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenTransactions\n","import { Duration, getUnixTime, startOfHour, sub } from 'date-fns'\nimport { useRouter } from 'next/router'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\n\nimport BigNumber from 'bignumber.js'\nimport fetchPoolChartData from 'state/info/queries/pools/chartData'\nimport { fetchAllPoolData, fetchAllPoolDataWithAddress } from 'state/info/queries/pools/poolData'\nimport fetchPoolTransactions from 'state/info/queries/pools/transactions'\nimport { fetchGlobalChartData } from 'state/info/queries/protocol/chart'\nimport { fetchProtocolData } from 'state/info/queries/protocol/overview'\nimport fetchTopTransactions from 'state/info/queries/protocol/transactions'\nimport fetchTokenChartData from 'state/info/queries/tokens/chartData'\nimport fetchPoolsForToken from 'state/info/queries/tokens/poolsForToken'\nimport fetchTokenPriceData from 'state/info/queries/tokens/priceData'\nimport { fetchAllTokenData, fetchAllTokenDataByAddresses } from 'state/info/queries/tokens/tokenData'\nimport fetchTokenTransactions from 'state/info/queries/tokens/transactions'\nimport { Block, Transaction } from 'state/info/types'\nimport { SWRConfiguration } from 'swr'\nimport useSWRImmutable from 'swr/immutable'\nimport { getDeltaTimestamps } from 'utils/getDeltaTimestamps'\nimport { getAprsForStableFarm } from 'utils/getAprsForStableFarm'\nimport { useBlockFromTimeStampSWR } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { checkIsStableSwap, MultiChainName } from './constant'\nimport { ChartEntry, PoolData, PriceChartEntry, ProtocolData, TokenData } from './types'\n\n// Protocol hooks\n\nconst refreshIntervalForInfo = 15000 // 15s\nconst SWR_SETTINGS_WITHOUT_REFETCH = {\n  errorRetryCount: 3,\n  errorRetryInterval: 3000,\n}\nconst SWR_SETTINGS: SWRConfiguration = {\n  refreshInterval: refreshIntervalForInfo,\n  keepPreviousData: true,\n  ...SWR_SETTINGS_WITHOUT_REFETCH,\n}\n\nexport const useProtocolDataSWR = (): ProtocolData | undefined => {\n  const chainName = useGetChainName()\n  const [t24, t48] = getDeltaTimestamps()\n  const { blocks } = useBlockFromTimeStampSWR([t24, t48])\n  const [block24, block48] = blocks ?? []\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data: protocolData } = useSWRImmutable(\n    chainName && block24 && block48 ? [`info/protocol/updateProtocolData/${type}`, chainName] : null,\n    () => fetchProtocolData(chainName, block24, block48),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n\n  return protocolData ?? undefined\n}\n\nexport const useProtocolChartDataSWR = (): ChartEntry[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data: chartData } = useSWRImmutable(\n    [`info/protocol/updateProtocolChartData/${type}`, chainName],\n    () => fetchGlobalChartData(chainName),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n  return chartData ?? undefined\n}\n\nexport const useProtocolTransactionsSWR = (): Transaction[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data: transactions } = useSWRImmutable(\n    [`info/protocol/updateProtocolTransactionsData/${type}`, chainName],\n    () => fetchTopTransactions(chainName),\n    SWR_SETTINGS, // update latest Transactions per 15s\n  )\n  return transactions ?? undefined\n}\n\nexport const useAllPoolDataSWR = () => {\n  const chainName = useGetChainName()\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks } = useBlockFromTimeStampSWR([t24h, t48h, t7d, t14d])\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    blocks && chainName && [`info/pools/data/${type}`, chainName],\n    () => fetchAllPoolData(blocks, chainName),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n  return useMemo(() => {\n    return data ?? {}\n  }, [data])\n}\n\nexport const usePoolDatasSWR = (poolAddresses: string[]): PoolData[] => {\n  const name = poolAddresses.join('')\n  const chainName = useGetChainName()\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks } = useBlockFromTimeStampSWR([t24h, t48h, t7d, t14d])\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    blocks && chainName && [`info/pool/data/${name}/${type}`, chainName],\n    () => fetchAllPoolDataWithAddress(blocks, chainName, poolAddresses),\n    SWR_SETTINGS,\n  )\n\n  return useMemo(() => {\n    return poolAddresses\n      .map((address) => {\n        return data?.[address]?.data\n      })\n      .filter((pool) => pool)\n  }, [data, poolAddresses])\n}\n\nexport const usePoolChartDataSWR = (address: string): ChartEntry[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    [`info/pool/chartData/${address}/${type}`, chainName],\n    () => fetchPoolChartData(chainName, address),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n  return data?.data ?? undefined\n}\n\nexport const usePoolTransactionsSWR = (address: string): Transaction[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    [`info/pool/transactionsData/${address}/${type}`, chainName],\n    () => fetchPoolTransactions(chainName, address),\n    SWR_SETTINGS,\n  )\n  return data?.data ?? undefined\n}\n\n// Tokens hooks\n\nexport const useAllTokenHighLight = (): TokenData[] => {\n  const chainName = useGetChainName()\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks } = useBlockFromTimeStampSWR([t24h, t48h, t7d, t14d])\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data, isLoading } = useSWRImmutable(\n    blocks && chainName && [`info/token/data/${type}`, chainName],\n    () => fetchAllTokenData(chainName, blocks),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n\n  const tokensWithData = useMemo(() => {\n    return data\n      ? Object.keys(data)\n          .map((k) => {\n            return data?.[k]?.data\n          })\n          .filter((d) => d && d.exists)\n      : []\n  }, [data])\n  return useMemo(() => {\n    return isLoading ? [] : tokensWithData ?? []\n  }, [isLoading, tokensWithData])\n}\n\nexport const useAllTokenDataSWR = (): {\n  [address: string]: { data?: TokenData }\n} => {\n  const chainName = useGetChainName()\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks } = useBlockFromTimeStampSWR([t24h, t48h, t7d, t14d])\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    blocks && chainName && [`info/token/data/${type}`, chainName],\n    () => fetchAllTokenData(chainName, blocks),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n  return data ?? {}\n}\n\nconst graphPerPage = 50\n\nconst fetcher = (addresses: string[], chainName: MultiChainName, blocks: Block[]) => {\n  const times = Math.ceil(addresses.length / graphPerPage)\n  const addressGroup = []\n  for (let i = 0; i < times; i++) {\n    addressGroup.push(addresses.slice(i * graphPerPage, (i + 1) * graphPerPage))\n  }\n  return Promise.all(addressGroup.map((d) => fetchAllTokenDataByAddresses(chainName, blocks, d)))\n}\n\nexport const useTokenDatasSWR = (addresses?: string[], withSettings = true): TokenData[] | undefined => {\n  const name = addresses.join('')\n  const chainName = useGetChainName()\n  const [t24h, t48h, t7d, t14d] = getDeltaTimestamps()\n  const { blocks } = useBlockFromTimeStampSWR([t24h, t48h, t7d, t14d])\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data, isLoading } = useSWRImmutable(\n    blocks && chainName && [`info/token/data/${name}/${type}`, chainName],\n    () => fetcher(addresses, chainName, blocks),\n    withSettings ? SWR_SETTINGS : SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n  const allData = useMemo(() => {\n    return data && data.length > 0\n      ? data.reduce((a, b) => {\n          return { ...a, ...b }\n        }, {})\n      : {}\n  }, [data])\n\n  const tokensWithData = useMemo(() => {\n    if (!addresses && allData) {\n      return undefined\n    }\n    return addresses\n      .map((a) => {\n        return allData?.[a]?.data\n      })\n      .filter((d) => d && d.exists)\n  }, [addresses, allData])\n\n  return useMemo(() => {\n    return isLoading ? [] : tokensWithData ?? undefined\n  }, [isLoading, tokensWithData])\n}\n\nexport const useTokenDataSWR = (address: string | undefined): TokenData | undefined => {\n  const allTokenData = useTokenDatasSWR([address])\n  return allTokenData.find((d) => d.address === address) ?? undefined\n}\n\nexport const usePoolsForTokenSWR = (address: string): string[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    [`info/token/poolAddress/${address}/${type}`, chainName],\n    () => fetchPoolsForToken(chainName, address),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n\n  return data?.addresses ?? undefined\n}\n\nexport const useTokenChartDataSWR = (address: string): ChartEntry[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    address && chainName && [`info/token/chartData/${address}/${type}`, chainName],\n    () => fetchTokenChartData(chainName, address),\n    SWR_SETTINGS,\n  )\n\n  return data?.data ?? undefined\n}\n\nexport const useTokenPriceDataSWR = (\n  address: string,\n  interval: number,\n  timeWindow: Duration,\n): PriceChartEntry[] | undefined => {\n  const utcCurrentTime = getUnixTime(new Date()) * 1000\n  const startTimestamp = getUnixTime(startOfHour(sub(utcCurrentTime, timeWindow)))\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    [`info/token/priceData/${address}/${type}`, chainName],\n    () => fetchTokenPriceData(chainName, address, interval, startTimestamp),\n    SWR_SETTINGS,\n  )\n  return data?.data ?? undefined\n}\n\nexport const useTokenTransactionsSWR = (address: string): Transaction[] | undefined => {\n  const chainName = useGetChainName()\n  const type = checkIsStableSwap() ? 'stableSwap' : 'swap'\n  const { data } = useSWRImmutable(\n    [`info/token/transactionsData/${address}/${type}`, chainName],\n    () => fetchTokenTransactions(chainName, address),\n    SWR_SETTINGS,\n  )\n  return data?.data ?? undefined\n}\n\nexport const useGetChainName = () => {\n  const { pathname, query } = useRouter()\n\n  const getChain = useCallback(() => {\n    if (pathname.includes('eth') || query.chain === 'eth') return 'ETH'\n    return 'BSC'\n  }, [pathname, query])\n  const [name, setName] = useState<MultiChainName | null>(() => getChain())\n  const result = useMemo(() => name, [name])\n\n  useEffect(() => {\n    setName(getChain())\n  }, [getChain])\n\n  return result\n}\n\nconst stableSwapAPRWithAddressesFetcher = async (addresses: string[]) => {\n  return Promise.all(addresses.map((d) => getAprsForStableFarm(d)))\n}\n\nexport const useStableSwapTopPoolsAPR = (addresses: string[]): Record<string, number> => {\n  const isStableSwap = checkIsStableSwap()\n  const chainName = useGetChainName()\n  const { data } = useSWRImmutable<BigNumber[]>(\n    isStableSwap && addresses?.length > 0 && [`info/pool/stableAPRs/Addresses/`, chainName],\n    () => stableSwapAPRWithAddressesFetcher(addresses),\n    SWR_SETTINGS_WITHOUT_REFETCH,\n  )\n  const addressWithAPR = useMemo(() => {\n    const result: Record<string, number> = {}\n    data?.forEach((d, index) => {\n      result[addresses[index]] = d?.toNumber()\n    })\n    return result\n  }, [addresses, data])\n  return useMemo(() => {\n    return isStableSwap ? addressWithAPR : {}\n  }, [isStableSwap, addressWithAPR])\n}\n\nexport const useMultiChainPath = () => {\n  const router = useRouter()\n  const { chainName } = router.query\n  return chainName ? `/${chainName}` : ''\n}\n\nexport const useStableSwapPath = () => {\n  return checkIsStableSwap() ? '?type=stableSwap' : ''\n}\n","export interface Block {\n  number: number\n  timestamp: string\n}\n\nexport interface ChartEntry {\n  date: number\n  volumeUSD: number\n  liquidityUSD: number\n}\n\n/**\n * Formatted type for Candlestick charts\n */\nexport interface PriceChartEntry {\n  time: number\n  open: number\n  close: number\n  high: number\n  low: number\n}\n\nexport enum TransactionType {\n  SWAP,\n  MINT,\n  BURN,\n}\n\nexport type Transaction = {\n  type: TransactionType\n  hash: string\n  timestamp: string\n  sender: string\n  token0Symbol: string\n  token1Symbol: string\n  token0Address: string\n  token1Address: string\n  amountUSD: number\n  amountToken0: number\n  amountToken1: number\n}\n\nexport interface ProtocolData {\n  volumeUSD: number\n  volumeUSDChange: number // in 24h, as percentage\n\n  liquidityUSD: number\n  liquidityUSDChange: number // in 24h, as percentage\n\n  txCount: number\n  txCountChange: number\n}\n\nexport interface ProtocolState {\n  readonly overview?: ProtocolData\n\n  readonly chartData?: ChartEntry[]\n\n  readonly transactions?: Transaction[]\n}\n\n// POOLS\n\nexport interface PoolData {\n  address: string\n\n  token0: {\n    name: string\n    symbol: string\n    address: string\n  }\n\n  token1: {\n    name: string\n    symbol: string\n    address: string\n  }\n\n  volumeUSD: number\n  volumeOutUSD?: number\n  volumeUSDChange: number\n  volumeUSDWeek: number\n  volumeOutUSDWeek?: number\n  volumeUSDChangeWeek: number\n\n  totalFees24h: number\n  totalFees7d: number\n  lpFees24h: number\n  lpFees7d: number\n  lpApr7d: number\n\n  liquidityUSD: number\n  liquidityUSDChange: number\n\n  token0Price: number\n  token1Price: number\n\n  liquidityToken0: number\n  liquidityToken1: number\n}\n\nexport interface PoolsState {\n  byAddress: {\n    [address: string]: {\n      data?: PoolData\n      chartData?: ChartEntry[]\n      transactions?: Transaction[]\n    }\n  }\n}\n\n// TOKENS\n\nexport type TokenData = {\n  exists: boolean\n\n  name: string\n  symbol: string\n  address: string\n  decimals: number\n\n  volumeUSD: number\n  volumeUSDChange: number\n  volumeUSDWeek: number\n  txCount: number\n\n  liquidityToken: number\n  liquidityUSD: number\n  liquidityUSDChange: number\n\n  priceUSD: number\n  priceUSDChange: number\n  priceUSDChangeWeek: number\n}\n\nexport interface TokensState {\n  byAddress: {\n    [address: string]: {\n      data?: TokenData\n      poolAddresses?: string[]\n      chartData?: ChartEntry[]\n      priceData: {\n        oldestFetchedTimestamp?: number\n        [secondsInterval: number]: PriceChartEntry[] | undefined\n      }\n      transactions?: Transaction[]\n    }\n  }\n}\n\n// Info redux state\nexport interface InfoState {\n  protocol: ProtocolState\n  pools: PoolsState\n  tokens: TokensState\n}\n","import BigNumber from 'bignumber.js'\nimport { gql } from 'graphql-request'\nimport _toLower from 'lodash/toLower'\nimport { getDeltaTimestamps } from './getDeltaTimestamps'\nimport { getBlocksFromTimestamps } from './getBlocksFromTimestamps'\nimport { stableSwapClient } from './graphql'\n\nexport const getAprsForStableFarm = async (stableSwapAddress?: string): Promise<BigNumber> => {\n  try {\n    const [, , t7d] = getDeltaTimestamps()\n    const [blockDay7Ago] = await getBlocksFromTimestamps([t7d])\n\n    const { virtualPriceAtLatestBlock, virtualPriceOneDayAgo: virtualPrice7DayAgo } = await stableSwapClient.request(\n      gql`\n        query virtualPriceStableSwap($stableSwapAddress: String, $blockDayAgo: Int!) {\n          virtualPriceAtLatestBlock: pair(id: $stableSwapAddress) {\n            virtualPrice\n          }\n          virtualPriceOneDayAgo: pair(id: $stableSwapAddress, block: { number: $blockDayAgo }) {\n            virtualPrice\n          }\n        }\n      `,\n      { stableSwapAddress: _toLower(stableSwapAddress), blockDayAgo: blockDay7Ago.number },\n    )\n\n    const virtualPrice = virtualPriceAtLatestBlock?.virtualPrice\n    const preVirtualPrice = virtualPrice7DayAgo?.virtualPrice\n\n    const current = new BigNumber(virtualPrice)\n    const prev = new BigNumber(preVirtualPrice)\n\n    const result = current.minus(prev).div(current).plus(1).pow(52).minus(1).times(100)\n\n    if (result.isFinite() && result.isGreaterThan(0)) {\n      return result\n    }\n    return new BigNumber(0)\n  } catch (error) {\n    console.error(error, '[LP APR Update] getAprsForStableFarm error')\n  }\n\n  return new BigNumber('0')\n}\n","import { getAmountChange, getPercentChange } from '../views/Info/utils/infoDataHelpers'\n\n/**\n * Given current value and value 1 and 2 periods (e.g. 1day + 2days, 1week - 2weeks) returns the amount change for latest period\n * and percentage change compared to the previous period.\n * @param valueNow - current value\n * @param valueOnePeriodAgo - value 1 period ago (e.g. 1 day or 1 week ago), period unit must be same as valueTwoPeriodsAgo\n * @param valueTwoPeriodsAgo - value 2 periods ago (e.g. 2 days or 2 weeks ago), period unit must be same as valueOnePeriodAgo\n * @returns amount change for the latest period and percentage change compared to previous period\n */\nexport const getChangeForPeriod = (\n  valueNow?: number,\n  valueOnePeriodAgo?: number,\n  valueTwoPeriodsAgo?: number,\n): [number, number] => {\n  const currentPeriodAmount = getAmountChange(valueNow, valueOnePeriodAgo)\n  const previousPeriodAmount = getAmountChange(valueOnePeriodAgo, valueTwoPeriodsAgo)\n  const percentageChange = getPercentChange(currentPeriodAmount, previousPeriodAmount)\n  return [currentPeriodAmount, percentageChange]\n}\n","import { getUnixTime, startOfMinute, subDays, subWeeks } from 'date-fns'\n\n/**\n * Returns UTC timestamps for 24h ago, 48h ago, 7d ago and 14d ago relative to current date and time\n */\nexport const getDeltaTimestamps = (): [number, number, number, number] => {\n  const utcCurrentTime = getUnixTime(new Date()) * 1000\n  const t24h = getUnixTime(startOfMinute(subDays(utcCurrentTime, 1)))\n  const t48h = getUnixTime(startOfMinute(subDays(utcCurrentTime, 2)))\n  const t7d = getUnixTime(startOfMinute(subWeeks(utcCurrentTime, 1)))\n  const t14d = getUnixTime(startOfMinute(subWeeks(utcCurrentTime, 2)))\n  return [t24h, t48h, t7d, t14d]\n}\n","/**\n * Get increase/decrease of value compared to the previous value (e.g. 24h volume compared to 24h volume the day before )\n * @param valueNow - more recent value\n * @param valueBefore - value to compare with\n */\nexport const getAmountChange = (valueNow?: number, valueBefore?: number) => {\n  if (valueNow && valueBefore) {\n    return valueNow - valueBefore\n  }\n  if (valueNow) {\n    return valueNow\n  }\n  return 0\n}\n\n/**\n * Get increase/decrease of value compared to the previous value as a percentage\n * @param valueNow - more recent value\n * @param valueBefore - value to compare with\n */\nexport const getPercentChange = (valueNow?: number, valueBefore?: number): number => {\n  if (valueNow && valueBefore) {\n    return ((valueNow - valueBefore) / valueBefore) * 100\n  }\n  return 0\n}\n"],"names":["mapMints","mint","type","TransactionType","hash","id","split","timestamp","sender","to","token0Symbol","pair","token0","symbol","token1Symbol","token1","token0Address","token1Address","amountUSD","parseFloat","amountToken0","amount0","amountToken1","amount1","mapBurns","burn","mapSwaps","swap","from","amount0In","amount0Out","amount1In","amount1Out","mapDayData","tokenDayData","date","volumeUSD","dailyVolumeUSD","liquidityUSD","totalLiquidityUSD","mapPairDayData","pairDayData","reserveUSD","fetchChartData","src_async_to_generator","Z","chainName","getEntityDayDatas","chartEntries","error","skip","allFound","_ref","data","fetchError","formattedDayDatas","availableDays","firstAvailableDayData","latestLiquidityUSD","endTimestamp","_state","sent","length","concat","console","warn","fromPairs","map","dayData","parseInt","ONE_DAY_UNIX","toFixed","Object","keys","dayOrdinal","multiChainStartTime","getUnixTime","Date","includes","toString","values","fetchChartDataWithAddress","address","getPoolChartData","query","gql","getMultiChainQueryEndPointWithStableSwap","request","startTime","pairDayDatas","fetchPoolChartData","getLpFeesAndApr","volumeUSDWeek","totalFees24h","TOTAL_FEE","totalFees7d","lpFees24h","LP_HOLDERS_FEE","lpFees7d","lpApr7d","WEEKS_IN_YEAR","Infinity","useBlockFromTimeStampSWR","timestamps","sortDirection","skipCount","useGetChainName","timestampsString","JSON","stringify","timestampsArray","parse","blocks","useSWRImmutable","getBlocksFromTimestamps","fetchTopPools","timestamp24hAgo","isStableSwap","firstCount","whereCondition","checkIsStableSwap","blacklist","multiChainTokenBlackList","p","fetchTopPoolAddresses","getDeltaTimestamps","POOL_AT_BLOCK","block","pools","addressesString","join","volumeOutUSDString","blockString","multiChainQueryMainToken","fetchPoolData","block24h","block48h","block7d","block14d","poolAddresses","parsePoolData","pairs","reduce","accum","poolData","reserve0","reserve1","token0Price","token1Price","volumeOutUSD","toLowerCase","src_object_spread_props","src_object_spread","fetchAllPoolDataWithAddress","formattedPoolData","formattedPoolData24h","formattedPoolData48h","formattedPoolData7d","formattedPoolData14d","number","now","oneDayAgo","twoDaysAgo","oneWeekAgo","twoWeeksAgo","current","oneDay","twoDays","week","twoWeeks","getChangeForPeriod","volumeUSDChange","getAmountChange","volumeOutUSDWeek","volumeUSDChangeWeek","liquidityUSDChange","getPercentChange","liquidityToken0","liquidityToken1","name","fetchAllPoolData","POOL_TRANSACTIONS","fetchPoolTransactions","mints","burns","swaps","_to_consumable_array","PANCAKE_DAY_DATAS","getOverviewChartData","pancakeDayDatas","fetchGlobalChartData","getOverviewData","factoryString","formatPancakeFactoryResponse","rawPancakeFactory","acc","cur","totalTransactions","totalVolumeUSD","fetchProtocolData","block24","block48","data24","data48","overviewData","overviewData24","overviewData48","txCount","txCountChange","Promise","all","undefined","src_sliced_to_array","apply","factories","pancakeFactories","GLOBAL_TRANSACTIONS","fetchTopTransactions","sort","a","b","getTokenChartData","tokenDayDatas","fetchTokenChartData","POOLS_FOR_TOKEN","transactionGT","fetchPoolsForToken","TOKEN_BLACKLIST","addresses","asToken0","asToken1","d","priceQueryConstructor","subqueries","fetchTokenPriceData","interval","startTimestamp","time","blocksLength","prices","tokenPrices","mainToken","sortedTokenPrices","formattedHistory","i","push","multiQuery","tokenAddress","multiChainQueryEndPoint","forEach","priceKey","derivedBNB","priceUSD","tokenPriceIndex","findIndex","tokenPrice","orderBy","open","close","high","low","fetchTopTokens","stableSwapQuery","union","tokens","t","multiChainTokenWhiteList","fetchTokenAddresses","TOKEN_AT_BLOCK","fetchTokenData","tokenAddresses","parseTokenData","tokenData","derivedUSD","tradeVolumeUSD","totalLiquidity","derivedETH","decimals","fetchAllTokenDataByAddresses","parsed","parsed24","parsed48","parsed7d","parsed14d","liquidityUSDOneDayAgo","liquidityToken","priceUSDOneDay","priceUSDWeek","priceUSDChange","priceUSDChangeWeek","exists","fetchAllTokenData","TOKEN_TRANSACTIONS","whereToken0","whereToken1","fetchTokenTransactions","mints0","mints1","burns0","burns1","swaps0","swaps1","mintsAs0","mintsAs1","burnsAs0","burnsAs1","swapsAs0","swapsAs1","SWR_SETTINGS_WITHOUT_REFETCH","errorRetryCount","errorRetryInterval","SWR_SETTINGS","refreshInterval","keepPreviousData","useProtocolDataSWR","protocolData","useProtocolChartDataSWR","chartData","useProtocolTransactionsSWR","transactions","useAllPoolDataSWR","useMemo","usePoolDatasSWR","filter","pool","usePoolChartDataSWR","usePoolTransactionsSWR","useAllTokenDataSWR","fetcher","times","Math","ceil","addressGroup","slice","useTokenDatasSWR","withSettings","isLoading","allData","tokensWithData","useTokenDataSWR","allTokenData","find","usePoolsForTokenSWR","useTokenChartDataSWR","useTokenPriceDataSWR","timeWindow","utcCurrentTime","startOfHour","sub","useTokenTransactionsSWR","useRouter","pathname","getChain","useCallback","chain","useState","setName","result","useEffect","stableSwapAPRWithAddressesFetcher","getAprsForStableFarm","useStableSwapTopPoolsAPR","addressWithAPR","index","toNumber","useMultiChainPath","router","useStableSwapPath","SWAP","MINT","BURN","_swc_helpers_src_async_to_generator_mjs__WEBPACK_IMPORTED_MODULE_6__","stableSwapAddress","t7d","blockDay7Ago","_ref1","virtualPriceAtLatestBlock","virtualPrice7DayAgo","virtualPrice","preVirtualPrice","prev","stableSwapClient","_toLower","blockDayAgo","virtualPriceOneDayAgo","BigNumber","minus","div","plus","pow","isFinite","isGreaterThan","valueNow","valueOnePeriodAgo","valueTwoPeriodsAgo","currentPeriodAmount","previousPeriodAmount","percentageChange","startOfMinute","subDays","subWeeks","valueBefore"],"sourceRoot":""}